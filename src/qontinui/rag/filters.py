"""Filter building for RAG search queries."""

from dataclasses import dataclass, field
from typing import Any

from .models import ElementType


@dataclass
class PredictedFilters:
    """
    Filters predicted from a natural language query.

    These filters are generated by an LLM to narrow down search results
    based on the user's intent.
    """

    # Element classification
    element_types: list[ElementType] = field(default_factory=list)
    element_subtypes: list[str] = field(default_factory=list)
    is_interactive: bool | None = None

    # Visual state
    visual_states: list[str] = field(default_factory=list)
    is_enabled: bool | None = None
    is_selected: bool | None = None

    # Source/context
    source_apps: list[str] = field(default_factory=list)
    state_ids: list[str] = field(default_factory=list)
    platforms: list[str] = field(default_factory=list)

    # Geometry constraints
    min_width: int | None = None
    max_width: int | None = None
    min_height: int | None = None
    max_height: int | None = None
    position_quadrants: list[str] = field(default_factory=list)

    # Text requirements
    has_text: bool | None = None
    min_text_length: int | None = None

    # State machine
    is_defining_element: bool | None = None
    is_shared: bool | None = None

    # Semantics
    semantic_roles: list[str] = field(default_factory=list)
    semantic_actions: list[str] = field(default_factory=list)
    style_families: list[str] = field(default_factory=list)


@dataclass
class SearchQuery:
    """
    Complete search query with text, filters, and search parameters.
    """

    # Query text/embedding
    query_text: str = ""
    query_embedding: list[float] | None = None

    # Filter criteria
    filters: PredictedFilters = field(default_factory=PredictedFilters)

    # Search parameters
    top_k: int = 10  # Number of results to return
    similarity_threshold: float = 0.0  # Minimum similarity score
    search_mode: str = "hybrid"  # "text", "image", or "hybrid"

    # Reranking
    use_reranking: bool = False
    reranking_model: str = ""


def build_filter_query(query: SearchQuery) -> dict[str, Any]:
    """
    Convert SearchQuery to vector database filter format.

    This function builds a filter dictionary compatible with Qdrant
    or similar vector databases.

    Args:
        query: Search query with filter criteria

    Returns:
        Dictionary representing the filter in vector DB format
    """
    filters = query.filters
    conditions: list[dict[str, Any]] = []

    # Element type filters
    if filters.element_types:
        conditions.append(
            {
                "key": "element_type",
                "match": {"any": [et.value for et in filters.element_types]},
            }
        )

    if filters.element_subtypes:
        conditions.append(
            {"key": "element_subtype", "match": {"any": filters.element_subtypes}}
        )

    # Boolean filters
    if filters.is_interactive is not None:
        conditions.append(
            {"key": "is_interactive", "match": {"value": filters.is_interactive}}
        )

    if filters.is_enabled is not None:
        conditions.append({"key": "is_enabled", "match": {"value": filters.is_enabled}})

    if filters.is_selected is not None:
        conditions.append(
            {"key": "is_selected", "match": {"value": filters.is_selected}}
        )

    if filters.has_text is not None:
        conditions.append({"key": "has_text", "match": {"value": filters.has_text}})

    if filters.is_defining_element is not None:
        conditions.append(
            {
                "key": "is_defining_element",
                "match": {"value": filters.is_defining_element},
            }
        )

    if filters.is_shared is not None:
        conditions.append({"key": "is_shared", "match": {"value": filters.is_shared}})

    # Visual state filters
    if filters.visual_states:
        conditions.append(
            {"key": "visual_state", "match": {"any": filters.visual_states}}
        )

    # Source filters
    if filters.source_apps:
        conditions.append({"key": "source_app", "match": {"any": filters.source_apps}})

    if filters.state_ids:
        conditions.append({"key": "state_id", "match": {"any": filters.state_ids}})

    if filters.platforms:
        conditions.append({"key": "platform", "match": {"any": filters.platforms}})

    # Position filters
    if filters.position_quadrants:
        conditions.append(
            {"key": "position_quadrant", "match": {"any": filters.position_quadrants}}
        )

    # Geometry range filters
    if filters.min_width is not None:
        conditions.append({"key": "width", "range": {"gte": filters.min_width}})

    if filters.max_width is not None:
        conditions.append({"key": "width", "range": {"lte": filters.max_width}})

    if filters.min_height is not None:
        conditions.append({"key": "height", "range": {"gte": filters.min_height}})

    if filters.max_height is not None:
        conditions.append({"key": "height", "range": {"lte": filters.max_height}})

    # Text length filters
    if filters.min_text_length is not None:
        conditions.append(
            {"key": "text_length", "range": {"gte": filters.min_text_length}}
        )

    # Semantic filters
    if filters.semantic_roles:
        conditions.append(
            {"key": "semantic_role", "match": {"any": filters.semantic_roles}}
        )

    if filters.semantic_actions:
        conditions.append(
            {"key": "semantic_action", "match": {"any": filters.semantic_actions}}
        )

    if filters.style_families:
        conditions.append(
            {"key": "style_family", "match": {"any": filters.style_families}}
        )

    # Return empty dict if no conditions, otherwise return must clause
    if not conditions:
        return {}

    # If single condition, return it directly
    if len(conditions) == 1:
        return conditions[0]

    # Multiple conditions - combine with AND logic
    return {"must": conditions}
