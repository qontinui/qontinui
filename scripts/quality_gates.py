#!/usr/bin/env python3
"""
Quality gates enforcement script for CI/CD.

This script checks all quality metrics against defined thresholds and returns
exit code 0 if all gates pass, 1 if any fail.

Usage:
    python scripts/quality_gates.py [--reports-dir /path/to/reports] [--verbose]

The script expects JSON reports generated by qontinui-devtools in the reports directory.
"""
import argparse
import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional


@dataclass
class QualityGate:
    """Represents a quality gate check."""

    name: str
    passed: bool
    current_value: float | int
    threshold: float | int
    details: str


@dataclass
class QualityThresholds:
    """Quality gate thresholds."""

    # Circular dependencies (zero tolerance)
    max_circular_dependencies: int = 0

    # God classes
    max_god_classes_critical: int = 43  # Current baseline

    # Security
    max_security_critical: int = 20  # Current baseline
    max_security_high: int = 100  # Don't fail on high, just warn

    # Type coverage
    min_type_coverage: float = 85.0  # Maintain at least 85%

    # Race conditions
    max_race_conditions_critical: int = 474  # Current baseline


class QualityGateChecker:
    """Checks quality metrics against defined thresholds."""

    def __init__(self, reports_dir: Path, thresholds: QualityThresholds, verbose: bool = False):
        self.reports_dir = reports_dir
        self.thresholds = thresholds
        self.verbose = verbose
        self.results: List[QualityGate] = []

    def check_circular_dependencies(self) -> bool:
        """Check for circular dependencies."""
        report_path = self.reports_dir / "circular_deps.json"
        if not report_path.exists():
            print(f"Warning: {report_path} not found, skipping check")
            return True

        with open(report_path) as f:
            data = json.load(f)

        cycles_found = len(data.get("cycles", []))
        passed = cycles_found <= self.thresholds.max_circular_dependencies

        self.results.append(
            QualityGate(
                name="Circular Dependencies",
                passed=passed,
                current_value=cycles_found,
                threshold=self.thresholds.max_circular_dependencies,
                details=f"{cycles_found} cycle(s) found (max: {self.thresholds.max_circular_dependencies})",
            )
        )

        if self.verbose and not passed:
            print(f"\n❌ Circular Dependencies Check Failed:")
            print(f"   Found {cycles_found} cycles (threshold: {self.thresholds.max_circular_dependencies})")
            if cycles_found > 0:
                print(f"   Cycles:")
                for cycle in data["cycles"][:5]:  # Show first 5
                    print(f"     - {' -> '.join(cycle['cycle'])}")
                if cycles_found > 5:
                    print(f"     ... and {cycles_found - 5} more")

        return passed

    def check_god_classes(self) -> bool:
        """Check for god classes exceeding thresholds."""
        report_path = self.reports_dir / "god_classes.json"
        if not report_path.exists():
            print(f"Warning: {report_path} not found, skipping check")
            return True

        with open(report_path) as f:
            data = json.load(f)

        # Count critical god classes (>500 lines OR >30 methods)
        critical_classes = [
            gc
            for gc in data.get("god_classes", [])
            if gc.get("num_lines", 0) > 500 or gc.get("num_methods", 0) > 30
        ]
        critical_count = len(critical_classes)
        passed = critical_count <= self.thresholds.max_god_classes_critical

        self.results.append(
            QualityGate(
                name="God Classes",
                passed=passed,
                current_value=critical_count,
                threshold=self.thresholds.max_god_classes_critical,
                details=f"{critical_count} critical god classes (max: {self.thresholds.max_god_classes_critical})",
            )
        )

        if self.verbose and not passed:
            print(f"\n❌ God Classes Check Failed:")
            print(
                f"   Found {critical_count} critical god classes (threshold: {self.thresholds.max_god_classes_critical})"
            )
            print(f"   Top offenders:")
            sorted_classes = sorted(
                critical_classes, key=lambda x: x.get("num_lines", 0), reverse=True
            )
            for gc in sorted_classes[:5]:
                print(
                    f"     - {gc['class_name']}: {gc['num_lines']} lines, {gc['num_methods']} methods, LCOM={gc.get('lcom', 0):.2f}"
                )

        return passed

    def check_security(self) -> bool:
        """Check security vulnerabilities."""
        report_path = self.reports_dir / "security.json"
        if not report_path.exists():
            print(f"Warning: {report_path} not found, skipping check")
            return True

        with open(report_path) as f:
            data = json.load(f)

        vulnerabilities = data.get("vulnerabilities", [])
        critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
        high_vulns = [v for v in vulnerabilities if v.get("severity") == "high"]

        critical_count = len(critical_vulns)
        high_count = len(high_vulns)

        passed = critical_count <= self.thresholds.max_security_critical

        self.results.append(
            QualityGate(
                name="Security",
                passed=passed,
                current_value=critical_count,
                threshold=self.thresholds.max_security_critical,
                details=f"{critical_count} critical vulnerabilities (max: {self.thresholds.max_security_critical}), {high_count} high",
            )
        )

        if self.verbose and not passed:
            print(f"\n❌ Security Check Failed:")
            print(
                f"   Found {critical_count} critical vulnerabilities (threshold: {self.thresholds.max_security_critical})"
            )
            print(f"   Also found {high_count} high severity vulnerabilities")
            print(f"   Top issues:")
            for vuln in critical_vulns[:5]:
                print(f"     - {vuln.get('file', 'unknown')}:{vuln.get('line', 0)} - {vuln.get('message', 'No details')}")

        if self.verbose and high_count > self.thresholds.max_security_high:
            print(
                f"\n⚠️  Warning: {high_count} high severity vulnerabilities (threshold: {self.thresholds.max_security_high})"
            )

        return passed

    def check_type_coverage(self) -> bool:
        """Check type hint coverage."""
        report_path = self.reports_dir / "types.json"
        if not report_path.exists():
            print(f"Warning: {report_path} not found, skipping check")
            return True

        with open(report_path) as f:
            data = json.load(f)

        coverage = data.get("overall_coverage", {}).get("coverage_percentage", 0.0)
        passed = coverage >= self.thresholds.min_type_coverage

        self.results.append(
            QualityGate(
                name="Type Coverage",
                passed=passed,
                current_value=coverage,
                threshold=self.thresholds.min_type_coverage,
                details=f"{coverage:.1f}% coverage (min: {self.thresholds.min_type_coverage}%)",
            )
        )

        if self.verbose and not passed:
            print(f"\n❌ Type Coverage Check Failed:")
            print(f"   Coverage: {coverage:.1f}% (minimum: {self.thresholds.min_type_coverage}%)")
            total_funcs = data.get("overall_coverage", {}).get("total_functions", 0)
            with_hints = data.get("overall_coverage", {}).get("functions_with_hints", 0)
            print(f"   {with_hints}/{total_funcs} functions have type hints")

        return passed

    def check_race_conditions(self) -> bool:
        """Check race conditions."""
        report_path = self.reports_dir / "race.json"
        if not report_path.exists():
            print(f"Warning: {report_path} not found, skipping check")
            return True

        with open(report_path) as f:
            data = json.load(f)

        race_conditions = data.get("race_conditions", [])
        critical_races = [rc for rc in race_conditions if rc.get("severity") == "critical"]
        critical_count = len(critical_races)
        total_count = len(race_conditions)

        passed = critical_count <= self.thresholds.max_race_conditions_critical

        self.results.append(
            QualityGate(
                name="Race Conditions",
                passed=passed,
                current_value=critical_count,
                threshold=self.thresholds.max_race_conditions_critical,
                details=f"{critical_count} critical race conditions (max: {self.thresholds.max_race_conditions_critical}), {total_count} total",
            )
        )

        if self.verbose and not passed:
            print(f"\n❌ Race Conditions Check Failed:")
            print(
                f"   Found {critical_count} critical race conditions (threshold: {self.thresholds.max_race_conditions_critical})"
            )
            print(f"   Total race conditions: {total_count}")
            print(f"   Top issues:")
            for rc in critical_races[:5]:
                print(
                    f"     - {rc.get('file', 'unknown')}:{rc.get('line', 0)} - {rc.get('type', 'unknown type')}"
                )

        return passed

    def run_all_checks(self) -> bool:
        """Run all quality gate checks."""
        all_passed = True

        print("Running quality gate checks...\n")

        all_passed &= self.check_circular_dependencies()
        all_passed &= self.check_god_classes()
        all_passed &= self.check_security()
        all_passed &= self.check_type_coverage()
        all_passed &= self.check_race_conditions()

        return all_passed

    def print_summary(self):
        """Print a summary of all checks."""
        print("\n" + "=" * 70)
        print("QUALITY GATE SUMMARY")
        print("=" * 70)

        max_name_len = max(len(r.name) for r in self.results) if self.results else 20

        for result in self.results:
            status = "✅ PASS" if result.passed else "❌ FAIL"
            print(f"{result.name:<{max_name_len}} | {status} | {result.details}")

        print("=" * 70)

        passed_count = sum(1 for r in self.results if r.passed)
        total_count = len(self.results)

        if passed_count == total_count:
            print(f"✅ All {total_count} quality gates passed!")
        else:
            failed_count = total_count - passed_count
            print(f"❌ {failed_count} of {total_count} quality gates failed")

        print("=" * 70)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Check quality gates for qontinui project",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--reports-dir",
        type=Path,
        default=Path("/tmp"),
        help="Directory containing quality reports (default: /tmp)",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Show detailed output for failures"
    )

    args = parser.parse_args()

    # Initialize thresholds (could be loaded from config file)
    thresholds = QualityThresholds()

    # Create checker
    checker = QualityGateChecker(args.reports_dir, thresholds, args.verbose)

    # Run all checks
    all_passed = checker.run_all_checks()

    # Print summary
    checker.print_summary()

    # Exit with appropriate code
    sys.exit(0 if all_passed else 1)


if __name__ == "__main__":
    main()
